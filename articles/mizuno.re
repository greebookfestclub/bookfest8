= 組合せ最適化してみる
== 概要
最近、組合せ最適化が話題になりつつあります。技術書典のサークル配置も組合せ最適化で決定されているようです@<bib>{giopt}。
本稿では組合せ最適化の典型問題である最大マッチングを数式に落とし込んだ後、pythonの数理モデリングツールであるPuLP@<bib>{pulp}を用いて実際に解くところまでをご紹介します。


== 組合せ最適化とは？
最適化問題の中で決定したいものが離散的なものを組合せ最適化問題と呼びます。実社会においては「効率的な訪問営業の順番」や「無線通信基地局の設置計画」等が組合せ最適化問題になります。組合せ最適化問題は得てしてNP困難なことが多く、現実的な時間で最適解を得られない場合が殆どです。しかし今回は比較的短時間で解けることが知られており、応用もしやすい「最大マッチング問題」を解いていきます。

=== 最大マッチング問題とは？
人に仕事を割り当てたり、広告枠を顧客に配分するとき、これらはマッチングによってモデル化出来ます。マッチングとは「何か」と「何か」の最適なペアを求める問題です。イメージとしては@<img>{mizuno_01}のように2つの要素の間に引かれている線から、選ばれている要素が被らないように線を選択する問題になります。このとき選んだ線の本数を最大化するのが最大マッチング問題です。

//indepimage[mizuno_01][マッチングのイメージ]{
//}

== 最大マッチング問題を定式化
前節で定義した最大マッチング問題を数式で定義していきましょう。理解を助けるために「美容院の予約システム」を最適化する設定で考えてみます。

===[column] 設定:美容院予約最適化
美容師がn人居て、営業時間が10:00~20:00、各美容師は一時間に一人お客さんを持てるとします。ここでお客さんがm人来て、それぞれ美容師と時間帯を指定して予約を取ろうとします。人気の美容師とそうでない美容師がいますが、上手いこと調節して取れる予約の数を最大化したいです。

=== 定数と変数
入力として与えられる定数と最適化によって決定される変数を考えます。お客さんと予約の枠（つまり美容師と時間帯のペア）は変更できるものではないので定数です。一方で、決めたいものは「お客さんと予約の枠のペア」なので、この2つを紐付けるか否かを表す変数を考えます。これは0か1の値を取る変数になります。

//indepimage[mizuno_02][定数と変数]{
//}

=== 目的関数と制約式
次に、大きくしたいもの（＝目的関数）と問題を表現するために変数が守るべきもの（＝制約式）を考えていきます。 目的関数は成約した予約の数なので、値が1となるxの数になります。つまり

//image[mizuno_03][目的関数]{
//}

となります。次に制約式として「各お客さんは美容院に高々一度だけ行く」は

//image[mizuno_04][制約式1]{
//}

と表せます。「各予約の枠はお客さんを高々1人割り当てることができる」は同様に

//image[mizuno_05][制約式2]{
//}

となります。最後に「望んでいない美容師を望んでいない時間に割り当てられても困る」ので,
//image[mizuno_06][制約式3]{
//}

を追加します。ここまでをまとめると、

//image[mizuno_07][定式化]{
//}

となり、これを解けば最適な予約表を得ることができます。


=== 定式化した問題を実際に解いてみよう
こうして立てたモデルを実際にPythonの数理モデリングツールであるPuLPを用いて解いてみます。詳しいコードの解説等は省略しますが、数式を直感的にコードに落とすことができます。

//list[solve][PuLPで解く][python]{
#!/usr/bin/env python
# coding:utf-8
import itertools
import pulp

# 最大化したい
prob = pulp.LpProblem('matching', sense = pulp.LpMaximize)

# お客さん集合
C = ['kouji', 'hiro', 'kaduki', 'shin', 'taiga', 'kakeru']

# 美容師集合
B_name = ['yamato','rui','jin','george']
B_time = ['10','11','12','13','14','15','16','17','18','19','20']
B = [ i[0]+i[1] for i in itertools.product(B_name, B_time)] 
# 変数
xs = pulp.LpVariable.dicts('x', (C,B), 0, 1, 'Binary')


# 目的関数
prob += pulp.lpSum([xs[c][b] for (c,b) in itertools.product(C,B) ])

# 制約条件
for c in C:
  prob += pulp.lpSum([xs[c][b] for b in B]) <= 1
for b in B: 
  prob += pulp.lpSum([xs[c][b] for c in C]) <= 1
# 予約データを反転させたもの 適宜入力処理
prob += xs["hiro"]["rui10"] == 0
prob += xs["hiro"]["rui11"] == 0
prob += xs["hiro"]["rui12"] == 0
prob += xs["kouji"]["rui13"] == 0
prob += xs["kouji"]["rui14"] == 0
prob += xs["kouji"]["rui16"] == 0
prob += xs["taiga"]["yamato13"] == 0
prob += xs["taiga"]["yamato14"] == 0
prob += xs["taiga"]["yamato16"] == 0

# 解く
status = prob.solve()
print("Status", pulp.LpStatus[status])

# 結果を出力
for (c,b) in itertools.product(C,B):
    if xs[c][b].value() == 1:
        print(c,b)
print("z", prob.objective.value())
//}

実行すると以下のような結果が得られます。小さな例ですが現実的な予約表が得られています。
//list[result][実行結果]{
('Status', 'Optimal')
('kouji', 'rui10')
('hiro', 'rui14')
('kaduki', 'yamato20')
('shin', 'yamato17')
('taiga', 'rui20')
('kakeru', 'jin11')
('z', 6.0)
//}

== まとめ
本稿では組合せ最適化の入門として、美容院の予約システムをマッチング問題に定式化し実際に解くところまでをご紹介しました。定式化の良い点は、「美容院の設備的に同時に3人までしか対応できない」のような追加の要求があったときに、制約式を変更することで容易に対応できる点です。定式化には様々なノウハウがあり、今回扱ったマッチング問題等は「完全ユニモジュラー性」を利用することで更に効率的な定式化に治すことが出来ます。もしも本稿が組合せ最適化や数理科学技術の入門や啓蒙に役立てば幸いです。続編を書く機会がありましたら、次こそは最適化を事業へ応用した例をご紹介できればと思っています。
